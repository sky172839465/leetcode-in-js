# 0108. Convert Sorted Array to Binary Search Tree
1. 如果輸入的 `nums` 是 `[]` 代表二元樹是空的直接返回 `null`
2. 從測試資料可以看出為了讓二元樹平均分配，是不斷用二分法取正中間的數值

### 流程
1. 假設輸入的二元樹為 `[3, 1, 5, 0, 4, 2, 6]` 結果應為

    ||||||||
    | :---: | :--- | :---: | :---: | :---: | :---: | :---: |
    ||||0||||
    |||1||2|||
    ||3||45||6||
2. 第一次進入 `nums` 長度為 `7` ，正中間的索引為 `3` ，所以起點為 `nums[3] === 0`
3. 接著把 `nums` 剖半個別給左右的子二元樹
4. `treeNode.left` 輸入 `[3, 1, 5]`
5. 重複 `step 2.` ， `nums` 長度為 `3` ，正中間的索引為 `1` ，所以節點為 `nums[1] === 1`
6. `treeNode.left.left` 輸入 `[3]` ， `nums` 長度為 `1` ，正中間的索引為 `0` ，所以節點為 `nums[0] === 3`
7. `treeNode.left.right` 輸入 `[5]` ， `nums` 長度為 `1` ，正中間的索引為 `0` ，所以節點為 `nums[0] === 5`
8. `treeNode.right` 輸入 `[4, 2, 6]`
9. 重複 `step 2.` ， `nums` 長度為 `3` ，正中間的索引為 `1` ，所以節點為 `nums[1] === 2`
10. `treeNode.right.left` 輸入 `[4]` ， `nums` 長度為 `1` ，正中間的索引為 `0` ，所以節點為 `nums[0] === 4`
11. `treeNode.right.right` 輸入 `[6]` ， `nums` 長度為 `1` ，正中間的索引為 `0` ，所以節點為 `nums[0] === 6`
12. 所有節點都跑完後回傳 `treeNode`
