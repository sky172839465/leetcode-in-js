# 0107. Binary Tree Level Order Traversal II
1. 如果輸入的 `root` 是 `null` 代表是空的直接返回 `[]`
2. 第一次進入時帶入層數 `1` ，因為他是第一層
3. 接著檢查 `result` 長度，如果比層數小代表這層還沒有走過，那就要在 `result` 陣列最前面新增這次 `node` 的值
4. 如果 `result` 長度比層數大或等於，代表這層有走過只要塞新的值進去就好了

### 流程
1. 假設輸入的二元樹為 `[0, 11, 22, 33]` 結果應為 `[[33], [11, 22], [0]]`
2. 第一次輸入 `node.val` 為 `0` ，層數 `1` ， `result` 長度為 `0` ，比層數小所以 `result` 開頭增加一筆變成 `[[0]]`
3. 第二次輸入 `node.left.val` 為 `11` ，層數 `2` ， `result` 長度為 `1` ，比層數小所以 `result` 開頭增加一筆變成 `[[11], [0]]`
4. 第三次輸入 `node.left.left.val` 為 `33` ，層數 `3` ， `result` 長度為 `2` ，比層數小所以 `result` 開頭增加一筆變成 `[33], [[11], [0]]`
5. 第四次輸入 `node.right.val` 為 `22` ，層數 `2` ， `result` 長度為 `3` ，比層數大所以在 `result` 第 `(3 - 2)` 項目新增 `22` ， `result` 變成 `[33], [[11, 22], [0]]`
6. 再來沒有 `node` 可以檢查所以最外層繼續執行，返回 `result`